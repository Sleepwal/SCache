# SCache

## 目录
```text
SCache/
    |--lru/
        |--lru.go  // lru 缓存淘汰策略
    |--byteview.go // 缓存值的抽象与封装
    |--cache.go    // 并发控制
    |--s_cache.go // 负责与外部交互，控制缓存存储和获取的主流程
    |--http.go     // 提供被其他节点访问的能力(基于http)
```

## 存储
- 存储的数据结构使用**map**，存储键值的映射关系
- 值使用**双向链表**连接起来

## 淘汰算法
缓存满了之后，使用**LRU（最近最少使用）算法**淘汰
- 相对于仅考虑时间因素的 FIFO 和仅考虑访问频率的 LFU，LRU 算法可以认为是相对平衡的一种淘汰算法。
- LRU 认为，如果数据最近被访问过，那么将来被访问的概率也会更高。
- LRU 算法的实现非常简单：
  - 维护一个队列，如果某条记录被访问了，则移动到队尾。
  - 那么队首则是最近最少访问的数据，淘汰该条记录即可。

## 并发缓存
使用mutex加锁
- Group 负责与用户的交互，并且控制缓存值存储和获取的流程。
- 在`cahce.go`中，对缓存进程操作时，加锁。

## HTTP服务器

## 一致性哈希

多个分布式节点时，使用哈希算法选取一个节点。
- 如果服务器的节点过少，容易引起 key 的倾斜。缓存节点间负载不均。 
- 为了解决这个问题，引入了虚拟节点的概念，一个真实节点对应多个虚拟节点。

## 分布式节点
- 注册节点(Register Peers)，借助一致性哈希算法选择节点。
- 实现 HTTP 客户端，与远程节点的服务端通信，代码约90行